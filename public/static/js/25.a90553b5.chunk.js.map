{"version":3,"sources":["../home/runner/work/react-sortablejs/react-sortablejs/node_modules/@parcel/scope-hoisting/lib/helpers.js","util.ts","react-sortable.tsx","../../../utils/src/browser-info.ts","../../../utils/src/utils.ts","../../../sortable/src/PluginManager.ts","../../../sortable/src/EventDispatcher.ts","../../../sortable/src/Sortable.ts","../../../plugins/swap/src/index.ts","../../../sortable/src/Animation.ts","../../../plugins/multi-drag/src/index.ts","../../../plugins/on-spill/src/index.ts","../../../plugins/auto-scroll/src/index.ts","../../src/modular-complete.ts","../node_modules/reactstrap/es/ListGroupItem.js"],"names":["g","e","__esModule","default","S","Array","isArray","j","Symbol","iterator","Object","from","t","n","prototype","toString","call","slice","constructor","name","test","TypeError","length","r","x","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","push","apply","I","arguments","forEach","P","getOwnPropertyDescriptors","defineProperties","defineProperty","value","configurable","writable","E","parentElement","removeChild","k","element","C","o","oldIndex","children","insertBefore","D","M","item","newIndex","swapItem","oldIndicies","map","multiDragElement","index","newIndicies","sort","A","concat","reverse","splice","R","U","L","_","H","N","B","q","key","T","setPrototypeOf","__proto__","F","Reflect","construct","sham","Proxy","Date","$","ReferenceError","G","getPrototypeOf","exports","Utils","O","J","dragging","z","create","d","c","u","p","ref","l","list","chosen","selected","setList","sortable","plugins","this","current","makeOptions","s","props","tag","style","className","id","i","getChildren","dataIdAttr","selectedClass","chosenClass","dragClass","fallbackClass","ghostClass","swapClass","f","replace","filtered","b","a","clone","onAdd","onChange","onChoose","onClone","onEnd","onFilter","onRemove","onSort","onStart","onUnchoose","onUpdate","onMove","onSpill","onSelect","onDeselect","indexOf","propertyIsEnumerable","w","prepareOnHandlerPropAndDOM","prepareOnHandlerProp","willInsertAfter","callOnHandlerProp","pullMode","clones","removeOnSpill","revertOnSpill","console","log","type","get","find","includes","ReactSortable","window","navigator","userAgent","match","capture","passive","addEventListener","removeEventListener","substring","matches","msMatchesSelector","webkitMatchesSelector","h","host","document","nodeType","parentNode","v","classList","m","defaultView","getComputedStyle","currentStyle","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","getElementsByTagName","scrollingElement","documentElement","y","getBoundingClientRect","top","left","bottom","right","height","width","innerHeight","innerWidth","parseInt","display","It","ghost","dragged","draggable","lastElementChild","previousElementSibling","nodeName","toUpperCase","scrollLeft","scrollTop","clientWidth","scrollWidth","clientHeight","scrollHeight","overflowX","overflowY","body","Math","round","setTimeout","Polymer","jQuery","Zepto","dom","cloneNode","getTime","X","initializeByDefault","Y","mount","hasOwnProperty","pluginEvent","eventCanceled","cancel","pluginName","options","initializePlugins","assign","defaults","modifyOption","getEventProperties","eventProperties","optionListeners","rootEl","targetEl","cloneEl","toEl","fromEl","oldDraggableIndex","newDraggableIndex","originalEvent","putSortable","extraEventProperties","charAt","substr","CustomEvent","createEvent","initEvent","bubbles","cancelable","to","lastPutMode","dispatchEvent","evt","bind","dragEl","parentEl","K","ghostEl","W","nextEl","lastDownEl","cloneHidden","dragStarted","lt","tt","activeSortable","active","V","Q","Z","hideGhostForTarget","xt","unhideGhostForTarget","Mt","cloneNowHidden","cloneNowShown","dispatchSortableEvent","et","nt","ot","it","rt","at","st","ct","ut","dt","ht","ft","pt","gt","vt","mt","bt","wt","Et","yt","Dt","_t","createElement","St","cssText","pointerEvents","Ct","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","marginLeft","marginRight","flexDirection","gridTemplateColumns","split","float","clear","Tt","group","join","checkPull","pull","checkPut","put","revertClone","preventDefault","stopPropagation","stopImmediatePropagation","Nt","Ot","touches","clientX","clientY","some","emptyInsertThreshold","target","_onDragOver","At","_isOutsideThisEl","el","disabled","store","handle","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","ignore","preventOnFilter","animation","easing","setData","textContent","dropBubble","dragoverBubble","delay","delayOnTouchOnly","touchStartThreshold","Number","devicePixelRatio","forceFallback","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","nativeDraggable","_onTapStart","captureAnimationState","rect","thisAnimationDuration","fromRect","addAnimationState","removeAnimationState","animateAll","clearTimeout","prevFromRect","prevToRect","toRect","sqrt","pow","animate","max","animationResetTimer","animationTime","animatingX","animatingY","forRepaintDummy","offsetWidth","animated","Pt","draggedRect","related","relatedRect","kt","Rt","Xt","tagName","src","href","charCodeAt","Yt","Bt","contains","_getDirection","pointerType","shadowRoot","path","composedPath","checked","button","isContentEditable","trim","_prepareDragStart","ownerDocument","nextSibling","_lastX","_lastY","_onDrop","_disableDelayedDragEvents","_triggerDragStart","_disableDelayedDrag","_delayedDragTouchMoveHandler","_dragStartTimer","abs","floor","_onTouchMove","_onDragStart","selection","empty","getSelection","removeAllRanges","_dragStarted","_appendGhost","_nulling","_emulateDragOver","elementFromPoint","appendChild","dataTransfer","_hideClone","cloneId","_loopId","setInterval","effectAllowed","_dragStartId","_ignoreWhileAnimating","nextElementSibling","isOwner","axis","revert","dragRect","targetRect","canSort","fromSortable","completed","changed","insertion","_showClone","_offMoveEvents","_offUpEvents","clearInterval","save","handleEvent","dropEffect","toArray","getAttribute","set","closest","option","destroy","querySelectorAll","removeAttribute","utils","on","off","css","is","extend","throttle","toggleClass","nextTick","cancelNextTick","detectDirection","getChild","version","Ht","Ft","Lt","Kt","Wt","jt","zt","Gt","Ut","qt","Vt","sortableIndex","Zt","Qt","changedTouches","$t","Jt","startIndex","dragStart","drop","te","ee","ne","oe","ie","re","ae","le","se","pid","ce","ue","scroll","scrollSensitivity","scrollSpeed","scrollFn","vx","vy","layer","bubbleScroll","_handleAutoScroll","_handleFallbackAutoScroll","dragOverCompleted","dragOverBubble","nulling","dragOverValid","swap","isEqualNode","_deselectMultiDrag","_checkKeyDown","_checkKeyUp","multiDragKey","multiDragKeyDown","isMultiDrag","delayStartGlobal","delayEnded","setupClone","showClone","hideClone","dragStartGlobal","multiDrag","dragOver","dragOverAnimationCapture","dragOverAnimationComplete","originalEvt","shiftKey","nullingGlobal","destroyGlobal","shift","select","deselect","items","toLowerCase","propTypes","tagPropType","PropTypes","bool","color","string","action","any","cssModule","object","handleDisabledOnClick","ListGroupItem","Tag","attributes","_objectWithoutPropertiesLoose","classes","mapToCssModules","classNames","onClick","React","_extends","defaultProps"],"mappings":"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","file":"static/js/25.a90553b5.chunk.js","sourcesContent":[null,"import { PropsWithChildren } from \"react\";\nimport Sortable, { Options } from \"sortablejs\";\nimport { MultiDragEvent } from \"./react-sortable\";\nimport { AllMethodNames, ItemInterface, ReactSortableProps } from \"./types\";\n\n/**\n * Removes the `node` from the DOM\n * @param node\n */\nexport function removeNode(node: HTMLElement): void {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\n/**\n * Inserts the `newChild` node at the given index in a parent\n * @param parent The parent HTML Element.\n * @param newChild A HTML eement to add as a child of the parent.\n * @param index index of the parent to place the new child in.\n */\nexport function insertNodeAt(\n  parent: HTMLElement,\n  newChild: HTMLElement,\n  index: number\n): void {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\n// @todo - create a dom handler function for arrays or not at all\n\n/** removes stuff from the dom in a nice order */\n// @todo - do I need parenElement?\nexport function handleDOMChanges<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  removeNodes(customs);\n  insertNodes(customs);\n}\n\nexport function removeNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => removeNode(curr.element));\n}\n\nexport function insertNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nexport function createCustoms<T extends ItemInterface>(\n  evt: MultiDragEvent,\n  list: T[]\n): Normalized<T>[] {\n  const mode = getMode(evt);\n  const parentElement = { parentElement: evt.from };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex!,\n        oldIndex: evt.oldIndex!,\n        parentElement: evt.from,\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag: Input = {\n        element: evt.item,\n        oldIndex: evt.oldIndex!,\n        newIndex: evt.newIndex!,\n        ...parentElement,\n      };\n      const swap: Input = {\n        element: evt.swapItem!,\n        oldIndex: evt.newIndex!,\n        newIndex: evt.oldIndex!,\n        ...parentElement,\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map<Input>((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement,\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n  const customs = createNormalized(custom, list);\n  return customs;\n}\n\n/** moves items form old index to new index without breaking anything ideally. */\nexport function handleStateChanges<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const a = handleStateRemove(normalized, list);\n  const b = handleStateAdd(normalized, a);\n  return b;\n}\n\nexport function handleStateRemove<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const newList = [...list];\n  normalized\n    .concat()\n    .reverse()\n    .forEach((curr) => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nexport function handleStateAdd<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[],\n  evt?: Sortable.SortableEvent,\n  clone?: ((currentItem: T, evt: Sortable.SortableEvent) => T) | undefined\n): T[] {\n  const newList = [...list];\n  normalized.forEach((curr) => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nexport function getMode(evt: MultiDragEvent): \"multidrag\" | \"swap\" | \"normal\" {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nexport function createNormalized<T extends ItemInterface>(\n  inputs: Input[],\n  list: T[]\n): Normalized<T>[] {\n  const normalized = inputs\n    .map<Normalized<T>>((curr) => ({ ...curr, item: list[curr.oldIndex] }))\n    .sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nexport interface Input {\n  parentElement: HTMLElement;\n  element: HTMLElement;\n  oldIndex: number;\n  newIndex: number;\n}\n\nexport interface Normalized<T> extends Input {\n  item: T;\n}\n\n/**\n * Removes the following group of properties from `props`,\n * leaving only `Sortable.Options` without any `on` methods.\n * @param props `ReactSortable.Props`\n */\nexport function destructurePropsForOptions<T>(\n  props: PropsWithChildren<ReactSortableProps<T>>\n): Exclude<Options, AllMethodNames> {\n  /* eslint-disable */\n  const {\n    // react sortable props\n    list,\n    setList,\n    children,\n    tag,\n    style,\n    className,\n    clone,\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange,\n    onChoose,\n    onClone,\n    onEnd,\n    onFilter,\n    onRemove,\n    onSort,\n    onStart,\n    onUnchoose,\n    onUpdate,\n    onMove,\n    onSpill,\n    onSelect,\n    onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/**\n * Construct a type with the properties of T except for those in type K.\n * Including this allows for backwards compatibility with earlier versions of TS.\n */\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n","import classNames from \"classnames\";\nimport {\n  Children,\n  cloneElement,\n  Component,\n  createElement,\n  createRef,\n  ReactElement,\n  RefObject,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport invariant from \"tiny-invariant\";\nimport {\n  AllMethodsExceptMove,\n  HandledMethodNames,\n  ItemInterface,\n  ReactSortableProps,\n  Store,\n  UnHandledMethodNames,\n} from \"./types\";\nimport {\n  createCustoms,\n  destructurePropsForOptions,\n  getMode,\n  handleStateAdd,\n  handleStateChanges,\n  handleStateRemove,\n  insertNodes,\n  removeNode,\n  removeNodes,\n} from \"./util\";\n\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\nconst store: Store = { dragging: null };\n\nexport class ReactSortable<T extends ItemInterface> extends Component<\n  ReactSortableProps<T>\n> {\n  /* eslint-disable-next-line */\n  static defaultProps: Partial<ReactSortableProps<any>> = {\n    clone: (item) => item,\n  };\n\n  private ref: RefObject<HTMLElement>;\n  constructor(props: ReactSortableProps<T>) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = createRef<HTMLElement>();\n\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = props.list.map((item) => ({\n      ...item,\n      chosen: false,\n      selected: false,\n    }));\n\n    props.setList(newList, this.sortable, store);\n    invariant(\n      //@ts-expect-error: Doesn't exist. Will deprecate soon.\n      !props.plugins,\n      `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `\n    );\n  }\n  componentDidMount(): void {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  }\n\n  render(): JSX.Element {\n    const { tag, style, className, id } = this.props;\n    const classicProps = { style, className, id };\n\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(\n      newTag,\n      {\n        // @todo - find a way (perhaps with the callback) to allow AntD components to work\n        ref: this.ref,\n        ...classicProps,\n      },\n      this.getChildren()\n    );\n  }\n\n  private getChildren() {\n    const {\n      children,\n      dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list,\n    } = this.props;\n\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return Children.map(children as ReactElement<any>[], (child, index) => {\n      const item = list[index];\n      const { className: prevClassName } = child.props;\n\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered,\n      };\n\n      const className = classNames(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered,\n        // [dragClass]: true,\n        // [fallbackClass]: true,\n        // [ghostClass]: true,\n        // [swapClass]: true\n      });\n\n      return cloneElement(child, {\n        [dataid]: child.key,\n        className,\n      });\n    });\n  }\n\n  /** Appends the `sortable` property to this component */\n  private get sortable(): Sortable | null {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find((k) => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key] as Sortable;\n  }\n\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions(): Options {\n    const DOMHandlers: HandledMethodNames[] = [\n      \"onAdd\",\n      \"onChoose\",\n      \"onDeselect\",\n      \"onEnd\",\n      \"onRemove\",\n      \"onSelect\",\n      \"onSpill\",\n      \"onStart\",\n      \"onUnchoose\",\n      \"onUpdate\",\n    ];\n    const NonDOMHandlers: UnHandledMethodNames[] = [\n      \"onChange\",\n      \"onClone\",\n      \"onFilter\",\n      \"onSort\",\n    ];\n    const newOptions: Options = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerPropAndDOM(name))\n    );\n    NonDOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerProp(name))\n    );\n\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove = (evt: MoveEvent, originalEvt: Event) => {\n      const { onMove } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return {\n      ...newOptions,\n      onMove,\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(\n    evtName: HandledMethodNames\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(\n    evtName: Exclude<AllMethodsExceptMove, HandledMethodNames>\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt: SortableEvent, evtName: AllMethodsExceptMove): void {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }\n\n  // SORTABLE DOM HANDLING\n\n  onAdd(evt: MultiDragEvent): void {\n    const { list, setList, clone } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...store.dragging!.props.list];\n    const customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n    const newList = handleStateAdd(customs, list, evt, clone).map((item) => ({\n      ...item,\n      selected: false,\n    }));\n    setList(newList, this.sortable, store);\n  }\n\n  onRemove(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const mode = getMode(evt);\n    const customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList);\n    // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index],\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map((item) => ({\n            ...item,\n            element: evt.clone,\n          }));\n          break;\n        case \"swap\":\n        default: {\n          invariant(\n            true,\n            `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`\n          );\n        }\n      }\n      removeNodes(customClones);\n\n      // replace selected items with cloned items\n      customs.forEach((curr) => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone!(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n\n    // remove item.selected from list\n    newList = newList.map((item) => ({ ...item, selected: false }));\n    setList(newList, this.sortable, store);\n  }\n\n  onUpdate(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    const newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  }\n\n  onStart(): void {\n    store.dragging = this;\n  }\n\n  onEnd(): void {\n    store.dragging = null;\n  }\n\n  onChoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        return {\n          ...item,\n          chosen: true,\n        };\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onUnchoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        return {\n          ...item,\n          chosen: false,\n        };\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onSpill(evt: SortableEvent): void {\n    const { removeOnSpill, revertOnSpill } = this.props;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  }\n\n  onSelect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) => ({ ...item, selected: false }));\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(\n          `\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`\n        );\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onDeselect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) => ({ ...item, selected: false }));\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n}\n\n// everything below this point can be removed\n// once @types has been merged. PR submited\ninterface MultiIndices {\n  multiDragElement: HTMLElement;\n  index: number;\n}\n\nexport interface MultiDragEvent extends SortableEvent {\n  // @todo - add this to @types\n  clones: HTMLElement[];\n  oldIndicies: MultiIndices[];\n  newIndicies: MultiIndices[];\n  swapItem: HTMLElement | null;\n}\n","function userAgent(pattern) {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));\n  }\n}\n\nexport const IE11OrLess = userAgent(\n  /(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i\n);\nexport const Edge = userAgent(/Edge/i);\nexport const FireFox = userAgent(/firefox/i);\nexport const Safari =\n  userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nexport const IOS = userAgent(/iP(ad|od|hone)/i);\nexport const ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n","import { IE11OrLess } from \"./browser-info\";\nimport Sortable from \"../../sortable/src/Sortable\";\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/ el, /**String*/ selector) {\n  if (!selector) return;\n\n  selector[0] === \">\" && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType\n    ? el.host\n    : el.parentNode;\n}\n\nfunction closest(\n  /**HTMLElement*/ el,\n  /**String*/ selector,\n  /**HTMLElement*/ ctx,\n  includeCTX\n) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (\n        (selector != null &&\n          (selector[0] === \">\"\n            ? el.parentNode === ctx && matches(el, selector)\n            : matches(el, selector))) ||\n        (includeCTX && el === ctx)\n      ) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while ((el = getParentOrHost(el)));\n  }\n\n  return null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? \"add\" : \"remove\"](name);\n    } else {\n      let className = (\" \" + el.className + \" \")\n        .replace(R_SPACE, \" \")\n        .replace(\" \" + name + \" \", \" \");\n      el.className = (className + (state ? \" \" + name : \"\")).replace(\n        R_SPACE,\n        \" \"\n      );\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  let style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, \"\");\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf(\"webkit\") === -1) {\n        prop = \"-webkit-\" + prop;\n      }\n\n      style[prop] = val + (typeof val === \"string\" ? \"\" : \"px\");\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  let appliedTransforms = \"\";\n  if (typeof el === \"string\") {\n    appliedTransforms = el;\n  } else {\n    do {\n      //@ts-ignore\n      let transform = css(el, \"transform\");\n\n      if (transform && transform !== \"none\") {\n        appliedTransforms = transform + \" \" + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  const matrixFn =\n    window.DOMMatrix ||\n    window.WebKitCSSMatrix ||\n    //@ts-ignore\n    window.CSSMatrix ||\n    //@ts-ignore\n    window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    let list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  let scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(\n  el,\n  relativeToContainingBlock,\n  relativeToNonStaticParent,\n  undoScale,\n  container\n) {\n  if (!el.getBoundingClientRect && el !== window) return;\n\n  let elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if (\n    (relativeToContainingBlock || relativeToNonStaticParent) &&\n    el !== window\n  ) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (\n          container &&\n          container.getBoundingClientRect &&\n          //@ts-ignore\n          (css(container, \"transform\") !== \"none\" ||\n            (relativeToNonStaticParent &&\n              //@ts-ignore\n              css(container, \"position\") !== \"static\"))\n        ) {\n          let containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -=\n            //@ts-ignore\n            containerRect.top + parseInt(css(container, \"border-top-width\"));\n          left -=\n            //@ts-ignore\n            containerRect.left + parseInt(css(container, \"border-left-width\"));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n\n          break;\n        }\n        /* jshint boss:true */\n      } while ((container = container.parentNode));\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    //@ts-ignore\n    let elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n\n      width /= scaleX;\n      height /= scaleY;\n\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height,\n  };\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  let parent = getParentAutoScrollElement(el, true),\n    //@ts-ignore\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    //@ts-ignore\n    let parentSideVal = getRect(parent)[parentSide],\n      visible;\n\n    if (parentSide === \"top\" || parentSide === \"left\") {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n\n    if (parent === getWindowScrollingElement()) break;\n\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options) {\n  let currentChild = 0,\n    i = 0,\n    children = el.children;\n\n  while (i < children.length) {\n    if (\n      children[i].style.display !== \"none\" &&\n      //@ts-ignore\n      children[i] !== Sortable.ghost &&\n      //@ts-ignore\n      children[i] !== Sortable.dragged &&\n      closest(children[i], options.draggable, el, false)\n    ) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n\n    i++;\n  }\n  return null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n  let last = el.lastElementChild;\n\n  while (\n    last &&\n    //@ts-ignore\n    (last === Sortable.ghost ||\n      //@ts-ignore\n      css(last, \"display\") === \"none\" ||\n      (selector && !matches(last, selector)))\n  ) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n  let index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while ((el = el.previousElementSibling)) {\n    if (\n      el.nodeName.toUpperCase() !== \"TEMPLATE\" &&\n      //@ts-ignore\n      el !== Sortable.clone &&\n      (!selector || matches(el, selector))\n    ) {\n      index++;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n  let offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      //@ts-ignore\n      let elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n  for (let i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n  let elem = el;\n  let gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (\n      elem.clientWidth < elem.scrollWidth ||\n      elem.clientHeight < elem.scrollHeight\n    ) {\n      //@ts-ignore\n      let elemCSS = css(elem);\n      if (\n        (elem.clientWidth < elem.scrollWidth &&\n          (elemCSS.overflowX == \"auto\" || elemCSS.overflowX == \"scroll\")) ||\n        (elem.clientHeight < elem.scrollHeight &&\n          (elemCSS.overflowY == \"auto\" || elemCSS.overflowY == \"scroll\"))\n      ) {\n        if (!elem.getBoundingClientRect || elem === document.body)\n          return getWindowScrollingElement();\n\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while ((elem = elem.parentNode));\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return (\n    Math.round(rect1.top) === Math.round(rect2.top) &&\n    Math.round(rect1.left) === Math.round(rect2.left) &&\n    Math.round(rect1.height) === Math.round(rect2.height) &&\n    Math.round(rect1.width) === Math.round(rect2.width)\n  );\n}\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      let args = arguments,\n        _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  //@ts-ignore\n  let Polymer = window.Polymer;\n  //@ts-ignore\n  let $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, \"position\", \"absolute\");\n  css(el, \"top\", rect.top);\n  css(el, \"left\", rect.left);\n  css(el, \"width\", rect.width);\n  css(el, \"height\", rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, \"position\", \"\");\n  css(el, \"top\", \"\");\n  css(el, \"left\", \"\");\n  css(el, \"width\", \"\");\n  css(el, \"height\", \"\");\n}\n\nconst expando = \"Sortable\" + new Date().getTime();\n\nexport {\n  on,\n  off,\n  matches,\n  getParentOrHost,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  indexOfObject,\n  getParentAutoScrollElement,\n  extend,\n  isRectEqual,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  clone,\n  setRect,\n  unsetRect,\n  expando,\n};\n","let plugins = [];\n\nconst defaults = {\n  initializeByDefault: true,\n};\n\nconst pluginManager = {\n  mount(plugin) {\n    // Set default static properties\n    for (let option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.push(plugin);\n  },\n  pluginEvent(eventName, sortable, evt) {\n    this.eventCanceled = false;\n    evt.cancel = () => {\n      this.eventCanceled = true;\n    };\n    const eventNameGlobal = eventName + \"Global\";\n    plugins.forEach((plugin) => {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (\n        sortable.options[plugin.pluginName] &&\n        sortable[plugin.pluginName][eventName]\n      ) {\n        sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n      }\n    });\n  },\n  initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach((plugin) => {\n      const pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n\n      let initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      Object.assign(defaults, initialized.defaults);\n    });\n\n    for (let option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      let modified = this.modifyOption(\n        sortable,\n        option,\n        sortable.options[option]\n      );\n      if (typeof modified !== \"undefined\") {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties(name, sortable) {\n    let eventProperties = {};\n    plugins.forEach((plugin) => {\n      if (typeof plugin.eventProperties !== \"function\") return;\n      Object.assign(\n        eventProperties,\n        plugin.eventProperties.call(sortable[plugin.pluginName], name)\n      );\n    });\n\n    return eventProperties;\n  },\n  modifyOption(sortable, name, value) {\n    let modifiedValue;\n    plugins.forEach((plugin) => {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (\n        plugin.optionListeners &&\n        typeof plugin.optionListeners[name] === \"function\"\n      ) {\n        modifiedValue = plugin.optionListeners[name].call(\n          sortable[plugin.pluginName],\n          value\n        );\n      }\n    });\n\n    return modifiedValue;\n  },\n};\n\nexport default pluginManager;\n","import { expando, IE11OrLess, Edge } from \"../../utils/src\";\nimport PluginManager from \"./PluginManager\";\n\nexport default function dispatchEvent({\n  sortable,\n  rootEl,\n  name,\n  targetEl,\n  cloneEl,\n  toEl,\n  fromEl,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  originalEvent,\n  putSortable,\n  extraEventProperties,\n}) {\n  sortable = sortable || (rootEl && rootEl[expando]);\n  if (!sortable) return;\n\n  let evt,\n    options = sortable.options,\n    onName = \"on\" + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  let allEventProperties = {\n    ...extraEventProperties,\n    ...PluginManager.getEventProperties(name, sortable),\n  };\n  for (let option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n","import { version } from \"../package.json\";\nimport AnimationStateManager from \"./Animation\";\nimport PluginManager from \"./PluginManager\";\nimport dispatchEvent from \"./EventDispatcher\";\n/**\n * @todo import as namespace: import * as utils from \"../../utils/src\"\n */\nimport {\n  on,\n  off,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  extend,\n  throttle,\n  scrollBy,\n  clone,\n  expando,\n  IE11OrLess,\n  Edge,\n  FireFox,\n  Safari,\n  IOS,\n  ChromeForAndroid,\n} from \"../../utils/src\";\n\nlet pluginEvent = function (\n  eventName,\n  sortable,\n  //@ts-ignore\n  { evt: originalEvent, ...data } = {}\n) {\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {\n    dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    dragStarted: moved,\n    putSortable,\n    //@ts-ignore\n    activeSortable: Sortable.active,\n    originalEvent,\n\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n\n    cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown() {\n      cloneHidden = false;\n    },\n\n    dispatchSortableEvent(name) {\n      _dispatchEvent({ sortable, name, originalEvent });\n    },\n\n    ...data,\n  });\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent({\n    putSortable,\n    cloneEl,\n    targetEl: dragEl,\n    rootEl,\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n    ...info,\n  });\n}\n\nlet dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [], // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nconst documentExists = typeof document !== \"undefined\",\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? \"cssFloat\" : \"float\",\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable =\n    documentExists &&\n    !ChromeForAndroid &&\n    !IOS &&\n    \"draggable\" in document.createElement(\"div\"),\n  supportCssPointerEvents = (function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    let el = document.createElement(\"x\");\n    el.style.cssText = \"pointer-events:auto\";\n    return el.style.pointerEvents === \"auto\";\n  })(),\n  _detectDirection = function (el, options) {\n    //@ts-ignore\n    let elCSS = css(el),\n      elWidth =\n        parseInt(elCSS.width) -\n        parseInt(elCSS.paddingLeft) -\n        parseInt(elCSS.paddingRight) -\n        parseInt(elCSS.borderLeftWidth) -\n        parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      //@ts-ignore\n      firstChildCSS = child1 && css(child1),\n      //@ts-ignore\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth =\n        firstChildCSS &&\n        parseInt(firstChildCSS.marginLeft) +\n          parseInt(firstChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child1).width,\n      secondChildWidth =\n        secondChildCSS &&\n        parseInt(secondChildCSS.marginLeft) +\n          parseInt(secondChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child2).width;\n\n    if (elCSS.display === \"flex\") {\n      return elCSS.flexDirection === \"column\" ||\n        elCSS.flexDirection === \"column-reverse\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (elCSS.display === \"grid\") {\n      return elCSS.gridTemplateColumns.split(\" \").length <= 1\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (child1 && firstChildCSS.float && firstChildCSS.float !== \"none\") {\n      let touchingSideChild2 =\n        firstChildCSS.float === \"left\" ? \"left\" : \"right\";\n\n      return child2 &&\n        (secondChildCSS.clear === \"both\" ||\n          secondChildCSS.clear === touchingSideChild2)\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    return child1 &&\n      (firstChildCSS.display === \"block\" ||\n        firstChildCSS.display === \"flex\" ||\n        firstChildCSS.display === \"table\" ||\n        firstChildCSS.display === \"grid\" ||\n        (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === \"none\") ||\n        (child2 &&\n          elCSS[CSSFloatProperty] === \"none\" &&\n          firstChildWidth + secondChildWidth > elWidth))\n      ? \"vertical\"\n      : \"horizontal\";\n  },\n  _dragElInRowColumn = function (dragRect, targetRect, vertical) {\n    let dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n\n    return (\n      dragElS1Opp === targetS1Opp ||\n      dragElS2Opp === targetS2Opp ||\n      dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2\n    );\n  },\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function (x, y) {\n    let ret;\n    sortables.some((sortable) => {\n      //@ts-ignore\n      if (lastChild(sortable)) return;\n\n      //@ts-ignore\n      let rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally =\n          x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically =\n          y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return (ret = sortable);\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function (options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        let sameGroup =\n          to.options.group.name &&\n          from.options.group.name &&\n          to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === \"clone\") {\n          return value;\n        } else if (typeof value === \"function\") {\n          return toFn(value(to, from, dragEl, evt), pull)(\n            to,\n            from,\n            dragEl,\n            evt\n          );\n        } else {\n          let otherGroup = (pull ? to : from).options.group.name;\n\n          return (\n            value === true ||\n            (typeof value === \"string\" && value === otherGroup) ||\n            (value.join && value.indexOf(otherGroup) > -1)\n          );\n        }\n      };\n    }\n\n    let group = {};\n    let originalGroup = options.group;\n\n    if (!originalGroup || typeof originalGroup != \"object\") {\n      originalGroup = { name: originalGroup };\n    }\n\n    //@ts-ignore\n    group.name = originalGroup.name;\n    //@ts-ignore\n    group.checkPull = toFn(originalGroup.pull, true);\n    //@ts-ignore\n    group.checkPut = toFn(originalGroup.put);\n    //@ts-ignore\n    group.revertClone = originalGroup.revertClone;\n\n    options.group = group;\n  },\n  _hideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"none\");\n    }\n  },\n  _unhideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"\");\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists) {\n  document.addEventListener(\n    \"click\",\n    function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    },\n    true\n  );\n}\n\nlet nearestEmptyInsertDetectEvent = function (evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      let event = {};\n      for (let i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      //@ts-ignore\n      event.target = event.rootEl = nearest;\n      //@ts-ignore\n      event.preventDefault = void 0;\n      //@ts-ignore\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nlet _checkOutsideTargetEl = function (evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw `Sortable: \\`el\\` must be an HTMLElement, not ${{}.toString.call(\n      el\n    )}`;\n  }\n\n  this.el = el; // root element\n  this.options = options = Object.assign({}, options);\n\n  // Export instance\n  el[expando] = this;\n\n  let defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? \">li\" : \">*\",\n    swapThreshold: 1, // percentage; 0 <= x <= 1\n    invertSwap: false, // invert always\n    invertedSwapThreshold: null, // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function () {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: \"sortable-ghost\",\n    chosenClass: \"sortable-chosen\",\n    dragClass: \"sortable-drag\",\n    ignore: \"a, img\",\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer, dragEl) {\n      dataTransfer.setData(\"Text\", dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: \"data-id\",\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold:\n      (Number.parseInt ? Number : window).parseInt(\n        //@ts-ignore\n        window.devicePixelRatio,\n        10\n      ) || 1,\n    forceFallback: false,\n    fallbackClass: \"sortable-fallback\",\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer:\n      //@ts-ignore\n      Sortable.supportPointer !== false && \"PointerEvent\" in window,\n    emptyInsertThreshold: 5,\n  };\n\n  //@ts-ignore\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (let name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (let fn in this) {\n    if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, \"pointerdown\", this._onTapStart);\n  } else {\n    on(el, \"mousedown\", this._onTapStart);\n    on(el, \"touchstart\", this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, \"dragover\", this);\n    on(el, \"dragenter\", this);\n  }\n\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store &&\n    options.store.get &&\n    this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  Object.assign(this, AnimationStateManager());\n}\n\nSortable.prototype = /** @lends Sortable.prototype */ {\n  constructor: Sortable,\n\n  _isOutsideThisEl: function (target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n\n  _getDirection: function (evt, target) {\n    return typeof this.options.direction === \"function\"\n      ? this.options.direction.call(this, evt, target, dragEl)\n      : this.options.direction;\n  },\n\n  _onTapStart: function (/** Event|TouchEvent */ evt) {\n    if (!evt.cancelable) return;\n    let _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch =\n        (evt.touches && evt.touches[0]) ||\n        (evt.pointerType && evt.pointerType === \"touch\" && evt),\n      target = (touch || evt).target,\n      originalTarget =\n        (evt.target.shadowRoot &&\n          ((evt.path && evt.path[0]) ||\n            (evt.composedPath && evt.composedPath()[0]))) ||\n        target,\n      filter = options.filter;\n\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n\n    if (\n      (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||\n      options.disabled\n    ) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (\n      !this.nativeDraggable &&\n      Safari &&\n      target &&\n      target.tagName.toUpperCase() === \"SELECT\"\n    ) {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === \"function\") {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: \"filter\",\n          targetEl: target,\n          toEl: el,\n          fromEl: el,\n        });\n        pluginEvent(\"filter\", _this, { evt });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(\",\").some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: \"filter\",\n            targetEl: target,\n            fromEl: el,\n            toEl: el,\n          });\n          pluginEvent(\"filter\", _this, { evt });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n\n  _prepareDragStart: function (\n    /** Event */ evt,\n    /** Touch */ touch,\n    /** HTMLElement */ target\n  ) {\n    let _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      //@ts-ignore\n      let dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n\n      //@ts-ignore\n      Sortable.dragged = dragEl;\n\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY,\n      };\n\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n\n      dragEl.style[\"will-change\"] = \"all\";\n\n      dragStartFn = function () {\n        pluginEvent(\"delayEnded\", _this, { evt });\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: \"choose\",\n          originalEvent: evt,\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(\",\").forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n\n      on(ownerDocument, \"dragover\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"mousemove\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"touchmove\", nearestEmptyInsertDetectEvent);\n\n      on(ownerDocument, \"mouseup\", _this._onDrop);\n      on(ownerDocument, \"touchend\", _this._onDrop);\n      on(ownerDocument, \"touchcancel\", _this._onDrop);\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent(\"delayStart\", this, { evt });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (\n        options.delay &&\n        (!options.delayOnTouchOnly || touch) &&\n        (!this.nativeDraggable || !(Edge || IE11OrLess))\n      ) {\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        on(ownerDocument, \"mouseup\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchend\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchcancel\", _this._disableDelayedDrag);\n        on(ownerDocument, \"mousemove\", _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, \"touchmove\", _this._delayedDragTouchMoveHandler);\n        options.supportPointer &&\n          on(ownerDocument, \"pointermove\", _this._delayedDragTouchMoveHandler);\n\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n\n  _delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/ e) {\n    let touch = e.touches ? e.touches[0] : e;\n    if (\n      Math.max(\n        Math.abs(touch.clientX - this._lastX),\n        Math.abs(touch.clientY - this._lastY)\n      ) >=\n      Math.floor(\n        this.options.touchStartThreshold /\n          ((this.nativeDraggable && window.devicePixelRatio) || 1)\n      )\n    ) {\n      this._disableDelayedDrag();\n    }\n  },\n\n  _disableDelayedDrag: function () {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n\n  _disableDelayedDragEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, \"mouseup\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchend\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchcancel\", this._disableDelayedDrag);\n    off(ownerDocument, \"mousemove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"touchmove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n\n  _triggerDragStart: function (/** Event */ evt, /** Touch */ touch) {\n    touch = touch || (evt.pointerType == \"touch\" && evt);\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, \"pointermove\", this._onTouchMove);\n      } else if (touch) {\n        on(document, \"touchmove\", this._onTouchMove);\n      } else {\n        on(document, \"mousemove\", this._onTouchMove);\n      }\n    } else {\n      on(dragEl, \"dragend\", this);\n      on(rootEl, \"dragstart\", this._onDragStart);\n    }\n\n    try {\n      //@ts-ignore\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          //@ts-ignore\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n\n  _dragStarted: function (fallback, evt) {\n    let _this = this;\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent(\"dragStarted\", this, { evt });\n\n      if (this.nativeDraggable) {\n        on(document, \"dragover\", _checkOutsideTargetEl);\n      }\n      let options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n\n      //@ts-ignore\n      Sortable.active = this;\n\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: \"start\",\n        originalEvent: evt,\n      });\n    } else {\n      this._nulling();\n    }\n  },\n\n  _emulateDragOver: function () {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      let target = document.elementFromPoint(\n        touchEvt.clientX,\n        touchEvt.clientY\n      );\n      let parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(\n          touchEvt.clientX,\n          touchEvt.clientY\n        );\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            let inserted;\n\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent,\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        } while (\n          /* jshint boss:true */\n          //@ts-ignore\n          (parent = parent.parentNode)\n        );\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n\n  _onTouchMove: function (/**TouchEvent*/ evt) {\n    if (tapEvt) {\n      let options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset =\n          PositionGhostAbsolutely &&\n          ghostRelativeParent &&\n          getRelativeScrollOffset(ghostRelativeParent),\n        dx =\n          (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]\n            : 0) /\n            (scaleX || 1),\n        dy =\n          (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]\n            : 0) /\n            (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      //@ts-ignore\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (\n          fallbackTolerance &&\n          Math.max(\n            Math.abs(touch.clientX - this._lastX),\n            Math.abs(touch.clientY - this._lastY)\n          ) < fallbackTolerance\n        ) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy,\n          };\n        }\n\n        let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;\n\n        css(ghostEl, \"webkitTransform\", cssMatrix);\n        css(ghostEl, \"mozTransform\", cssMatrix);\n        css(ghostEl, \"msTransform\", cssMatrix);\n        css(ghostEl, \"transform\", cssMatrix);\n\n        lastDx = dx;\n        lastDy = dy;\n\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n\n  _appendGhost: function () {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      let container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (\n          //@ts-ignore\n          css(ghostRelativeParent, \"position\") === \"static\" &&\n          //@ts-ignore\n          css(ghostRelativeParent, \"transform\") === \"none\" &&\n          ghostRelativeParent !== document\n        ) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (\n          ghostRelativeParent !== document.body &&\n          ghostRelativeParent !== document.documentElement\n        ) {\n          if (ghostRelativeParent === document)\n            ghostRelativeParent = getWindowScrollingElement();\n\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(\n          ghostRelativeParent\n        );\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n\n      css(ghostEl, \"transition\", \"\");\n      css(ghostEl, \"transform\", \"\");\n\n      css(ghostEl, \"box-sizing\", \"border-box\");\n      css(ghostEl, \"margin\", 0);\n      css(ghostEl, \"top\", rect.top);\n      css(ghostEl, \"left\", rect.left);\n      css(ghostEl, \"width\", rect.width);\n      css(ghostEl, \"height\", rect.height);\n      css(ghostEl, \"opacity\", \"0.8\");\n      css(ghostEl, \"position\", PositionGhostAbsolutely ? \"absolute\" : \"fixed\");\n      css(ghostEl, \"zIndex\", \"100000\");\n      css(ghostEl, \"pointerEvents\", \"none\");\n\n      //@ts-ignore\n      Sortable.ghost = ghostEl;\n\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(\n        ghostEl,\n        \"transform-origin\",\n        (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +\n          \"% \" +\n          (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +\n          \"%\"\n      );\n    }\n  },\n\n  _onDragStart: function (/**Event*/ evt, /**boolean*/ fallback) {\n    let _this = this;\n    let dataTransfer = evt.dataTransfer;\n    let options = _this.options;\n\n    pluginEvent(\"dragStart\", this, { evt });\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n\n    pluginEvent(\"setupClone\", this);\n    //@ts-ignore\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n\n      cloneEl.draggable = false;\n      cloneEl.style[\"will-change\"] = \"\";\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      //@ts-ignore\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent(\"clone\", _this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: \"clone\",\n      });\n    });\n\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, \"mouseup\", _this._onDrop);\n      off(document, \"touchend\", _this._onDrop);\n      off(document, \"touchcancel\", _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = \"move\";\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, \"drop\", _this);\n\n      // #1276 fix:\n      css(dragEl, \"transform\", \"translateZ(0)\");\n    }\n\n    awaitingDragStarted = true;\n\n    _this._dragStartId = _nextTick(\n      _this._dragStarted.bind(_this, fallback, evt)\n    );\n    on(document, \"selectstart\", _this);\n\n    moved = true;\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"none\");\n    }\n  },\n\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function (/**Event*/ evt) {\n    let el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      //@ts-ignore\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, {\n        evt,\n        isOwner,\n        axis: vertical ? \"vertical\" : \"horizontal\",\n        revert,\n        dragRect,\n        targetRect,\n        canSort,\n        fromSortable,\n        target,\n        completed,\n        onMove(target, after) {\n          return onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            //@ts-ignore\n            getRect(target),\n            evt,\n            after\n          );\n        },\n        changed,\n        ...extra,\n      });\n    }\n\n    // Capture animation state\n    function capture() {\n      //@ts-ignore\n      dragOverEvent(\"dragOverAnimationCapture\");\n\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent(\"dragOverCompleted\", { insertion });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : activeSortable.options.ghostClass,\n            false\n          );\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        //@ts-ignore\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n          //@ts-ignore\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          //@ts-ignore\n          dragOverEvent(\"dragOverAnimationComplete\");\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (\n        (target === dragEl && !dragEl.animated) ||\n        (target === el && !target.animated)\n      ) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n      return (completedFired = true);\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      //@ts-ignore\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: \"change\",\n        toEl: el,\n        newIndex,\n        newDraggableIndex,\n        originalEvent: evt,\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n\n    //@ts-ignore\n    dragOverEvent(\"dragOver\");\n    //@ts-ignore\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (\n      dragEl.contains(evt.target) ||\n      (target.animated && target.animatingX && target.animatingY) ||\n      _this._ignoreWhileAnimating === target\n    ) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (\n      activeSortable &&\n      !options.disabled &&\n      (isOwner\n        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n        : putSortable === this ||\n          ((this.lastPutMode = activeGroup.checkPull(\n            this,\n            activeSortable,\n            dragEl,\n            evt\n          )) &&\n            group.checkPut(this, activeSortable, dragEl, evt)))\n    ) {\n      vertical = this._getDirection(evt, target) === \"vertical\";\n\n      //@ts-ignore\n      dragRect = getRect(dragEl);\n\n      //@ts-ignore\n      dragOverEvent(\"dragOverValid\");\n      //@ts-ignore\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n\n        this._hideClone();\n\n        //@ts-ignore\n        dragOverEvent(\"revert\");\n\n        //@ts-ignore\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      let elLastChild = lastChild(el, options.draggable);\n\n      if (\n        !elLastChild ||\n        (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)\n      ) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // assign target only if condition is true\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          //@ts-ignore\n          targetRect = getRect(target);\n        }\n\n        if (\n          onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            targetRect,\n            evt,\n            !!target\n          ) !== false\n        ) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        //@ts-ignore\n        targetRect = getRect(target);\n        let direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(\n            (dragEl.animated && dragEl.toRect) || dragRect,\n            (target.animated && target.toRect) || targetRect,\n            vertical\n          ),\n          side1 = vertical ? \"top\" : \"left\",\n          scrolledPastTop =\n            isScrolledPast(target, \"top\", \"top\") ||\n            isScrolledPast(dragEl, \"top\", \"top\"),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert =\n            (!differentRowCol && options.invertSwap) || differentLevel;\n        }\n\n        direction = _getSwapDirection(\n          evt,\n          target,\n          targetRect,\n          vertical,\n          differentRowCol ? 1 : options.swapThreshold,\n          options.invertedSwapThreshold == null\n            ? options.swapThreshold\n            : options.invertedSwapThreshold,\n          isCircumstantialInvert,\n          lastTarget === target\n        );\n\n        let sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          //@ts-ignore\n          let dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (\n            sibling &&\n            //@ts-ignore\n            (css(sibling, \"display\") === \"none\" || sibling === ghostEl)\n          );\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n\n        lastDirection = direction;\n\n        let nextSibling = target.nextElementSibling,\n          after = false;\n\n        after = direction === 1;\n\n        let moveVector = onMove(\n          rootEl,\n          el,\n          dragEl,\n          dragRect,\n          target,\n          targetRect,\n          evt,\n          after\n        );\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(\n              dragEl,\n              after ? nextSibling : target\n            );\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(\n              scrolledPastTop,\n              0,\n              scrollBefore - scrolledPastTop.scrollTop\n            );\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(\n              //@ts-ignore\n              targetBeforeFirstSwap - getRect(target)[side1]\n            );\n          }\n          changed();\n\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n\n  _ignoreWhileAnimating: null,\n\n  _offMoveEvents: function () {\n    off(document, \"mousemove\", this._onTouchMove);\n    off(document, \"touchmove\", this._onTouchMove);\n    off(document, \"pointermove\", this._onTouchMove);\n    off(document, \"dragover\", nearestEmptyInsertDetectEvent);\n    off(document, \"mousemove\", nearestEmptyInsertDetectEvent);\n    off(document, \"touchmove\", nearestEmptyInsertDetectEvent);\n  },\n\n  _offUpEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n\n    off(ownerDocument, \"mouseup\", this._onDrop);\n    off(ownerDocument, \"touchend\", this._onDrop);\n    off(ownerDocument, \"pointerup\", this._onDrop);\n    off(ownerDocument, \"touchcancel\", this._onDrop);\n    off(document, \"selectstart\", this);\n  },\n\n  _onDrop: function (/**Event*/ evt) {\n    let el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    pluginEvent(\"drop\", this, {\n      evt,\n    });\n\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n\n    clearInterval(this._loopId);\n\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, \"drop\", this);\n      off(el, \"dragstart\", this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"\");\n    }\n\n    css(dragEl, \"transform\", \"\");\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        // Remove clone(s)\n        cloneEl &&\n          cloneEl.parentNode &&\n          cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, \"dragend\", this);\n        }\n\n        _disableDraggable(dragEl);\n        dragEl.style[\"will-change\"] = \"\";\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : this.options.ghostClass,\n            false\n          );\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: \"unchoose\",\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt,\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"add\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: \"remove\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"sort\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: \"sort\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: \"update\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: \"sort\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n            }\n          }\n        }\n\n        //@ts-ignore\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: \"end\",\n            toEl: parentEl,\n            originalEvent: evt,\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n\n  _nulling: function () {\n    pluginEvent(\"nulling\", this);\n    //@ts-ignore\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n\n  handleEvent: function (/**Event*/ evt) {\n    switch (evt.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(evt);\n        break;\n\n      case \"dragenter\":\n      case \"dragover\":\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n\n      case \"selectstart\":\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function () {\n    let order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function (order) {\n    let items = {},\n      rootEl = this.el;\n\n    this.toArray().forEach(function (id, i) {\n      let el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function () {\n    let store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function (el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function (name, value) {\n    let options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      let modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== \"undefined\") {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === \"group\") {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function () {\n    pluginEvent(\"destroy\", this);\n    let el = this.el;\n\n    el[expando] = null;\n\n    off(el, \"mousedown\", this._onTapStart);\n    off(el, \"touchstart\", this._onTapStart);\n    off(el, \"pointerdown\", this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, \"dragover\", this);\n      off(el, \"dragenter\", this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll(\"[draggable]\"), function (\n      el\n    ) {\n      el.removeAttribute(\"draggable\");\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n\n    this.el = el = null;\n  },\n\n  _hideClone: function () {\n    if (!cloneHidden) {\n      pluginEvent(\"hideClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      css(cloneEl, \"display\", \"none\");\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n\n  _showClone: function (putSortable) {\n    if (putSortable.lastPutMode !== \"clone\") {\n      this._hideClone();\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent(\"showClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, \"display\", \"\");\n      cloneHidden = false;\n    }\n  },\n};\n\nfunction _globalDragOver(/**Event*/ evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = \"move\";\n  }\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction onMove(\n  fromEl,\n  toEl,\n  dragEl,\n  dragRect,\n  targetEl,\n  targetRect,\n  originalEvent,\n  willInsertAfter\n) {\n  let evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(\"move\", {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(\"move\", true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  //@ts-ignore\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n\n  evt.originalEvent = originalEvent;\n\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  //@ts-ignore\n  let rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  const spacer = 10;\n\n  return vertical\n    ? evt.clientX > rect.right + spacer ||\n        (evt.clientX <= rect.right &&\n          evt.clientY > rect.bottom &&\n          evt.clientX >= rect.left)\n    : (evt.clientX > rect.right && evt.clientY > rect.top) ||\n        (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);\n}\n\nfunction _getSwapDirection(\n  evt,\n  target,\n  targetRect,\n  vertical,\n  swapThreshold,\n  invertedSwapThreshold,\n  invertSwap,\n  isLastTarget\n) {\n  let mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (\n        !pastFirstInvertThresh &&\n        (lastDirection === 1\n          ? mouseOnAxis > targetS1 + (targetLength * invertedSwapThreshold) / 2\n          : mouseOnAxis < targetS2 - (targetLength * invertedSwapThreshold) / 2)\n      ) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (\n          lastDirection === 1\n            ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n            : mouseOnAxis > targetS2 - targetMoveDistance\n        ) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (\n        mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&\n        mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2\n      ) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (\n      mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||\n      mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2\n    ) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\nfunction _getInsertDirection(target) {\n  //@ts-ignore\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\nfunction _generateId(el) {\n  let str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n\n  let inputs = root.getElementsByTagName(\"input\");\n  let idx = inputs.length;\n\n  while (idx--) {\n    let el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, \"touchmove\", function (evt) {\n    //@ts-ignore\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function (el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n};\n\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\nSortable.mount = function (...plugins) {\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n\n  plugins.forEach((plugin) => {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw `Sortable: Mounted plugin must be a constructor function, not ${{}.toString.call(\n        plugin\n      )}`;\n    }\n    if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nexport default Sortable;\n","import { toggleClass, index } from \"../../../utils/src\";\n\nlet lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\",\n    };\n  }\n\n  Swap.prototype = {\n    dragStart({ dragEl }) {\n      lastSwapEl = dragEl;\n    },\n    dragOverValid({\n      completed,\n      target,\n      onMove,\n      activeSortable,\n      changed,\n      cancel,\n    }) {\n      if (!activeSortable.options.swap) return;\n      let el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        let prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n\n      completed(true);\n      cancel();\n    },\n    drop({ activeSortable, putSortable, dragEl }) {\n      let toSortable = putSortable || this.sortable;\n      let options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (\n        lastSwapEl &&\n        (options.swap || (putSortable && putSortable.options.swap))\n      ) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable)\n            activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling() {\n      lastSwapEl = null;\n    },\n  };\n\n  return Object.assign(Swap, {\n    pluginName: \"swap\",\n    eventProperties() {\n      return {\n        swapItem: lastSwapEl,\n      };\n    },\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  let p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n\n  //@ts-ignore\n  i1 = index(n1);\n  //@ts-ignore\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nexport default SwapPlugin;\n","import {\n  getRect,\n  css,\n  matrix,\n  isRectEqual,\n  indexOfObject,\n} from \"../../utils/src\";\nimport * as Sortable from \"./Sortable\";\n\nexport default function AnimationStateManager() {\n  let animationStates = [],\n    animationCallbackId;\n\n  return {\n    captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      let children = [].slice.call(this.el.children);\n\n      children.forEach((child) => {\n        //@ts-ignore\n        if (css(child, \"display\") === \"none\" || child === Sortable.ghost)\n          return;\n        animationStates.push({\n          target: child,\n          //@ts-ignore\n          rect: getRect(child),\n        });\n        let fromRect = { ...animationStates[animationStates.length - 1].rect };\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          let childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n\n    addAnimationState(state) {\n      animationStates.push(state);\n    },\n\n    removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, { target }), 1);\n    },\n\n    animateAll(callback) {\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === \"function\") callback();\n        return;\n      }\n\n      let animating = false,\n        animationTime = 0;\n\n      animationStates.forEach((state) => {\n        let time = 0,\n          animatingThis = false,\n          target = state.target,\n          fromRect = target.fromRect,\n          //@ts-ignore\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (\n            isRectEqual(prevFromRect, toRect) &&\n            !isRectEqual(fromRect, toRect) &&\n            // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) /\n              (animatingRect.left - toRect.left) ===\n              (fromRect.top - toRect.top) / (fromRect.left - toRect.left)\n          ) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(\n              animatingRect,\n              prevFromRect,\n              prevToRect,\n              this.options\n            );\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = this.options.animation;\n          }\n          this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === \"function\") callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === \"function\") callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n\n    animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, \"transition\", \"\");\n        css(target, \"transform\", \"\");\n        //@ts-ignore\n        let elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n\n        css(\n          target,\n          \"transform\",\n          \"translate3d(\" + translateX + \"px,\" + translateY + \"px,0)\"\n        );\n\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(\n          target,\n          \"transition\",\n          \"transform \" +\n            duration +\n            \"ms\" +\n            (this.options.easing ? \" \" + this.options.easing : \"\")\n        );\n        css(target, \"transform\", \"translate3d(0,0,0)\");\n        typeof target.animated === \"number\" && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, \"transition\", \"\");\n          css(target, \"transform\", \"\");\n          target.animated = false;\n\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    },\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return (\n    (Math.sqrt(\n      Math.pow(fromRect.top - animatingRect.top, 2) +\n        Math.pow(fromRect.left - animatingRect.left, 2)\n    ) /\n      Math.sqrt(\n        Math.pow(fromRect.top - toRect.top, 2) +\n          Math.pow(fromRect.left - toRect.left, 2)\n      )) *\n    options.animation\n  );\n}\n","import {\n  toggleClass,\n  getRect,\n  index,\n  closest,\n  on,\n  off,\n  clone,\n  css,\n  setRect,\n  unsetRect,\n  matrix,\n  expando,\n} from \"../../../utils/src\";\n\nimport dispatchEvent from \"../../../sortable/src/EventDispatcher\";\n\nlet multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect, // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false, // Initial multi-drag fold when drag started\n  folding = false, // Folding any other time\n  dragStarted = false,\n  dragEl,\n  clonesFromRect,\n  clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, \"pointerup\", this._deselectMultiDrag);\n    } else {\n      on(document, \"mouseup\", this._deselectMultiDrag);\n      on(document, \"touchend\", this._deselectMultiDrag);\n    }\n\n    on(document, \"keydown\", this._checkKeyDown);\n    on(document, \"keyup\", this._checkKeyUp);\n\n    this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData(dataTransfer, dragEl) {\n        let data = \"\";\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach((multiDragElement, i) => {\n            data += (!i ? \"\" : \", \") + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData(\"Text\", data);\n      },\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n\n    delayStartGlobal({ dragEl: dragged }) {\n      dragEl = dragged;\n    },\n\n    delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl);\n    },\n\n    setupClone({ sortable, cancel }) {\n      if (!this.isMultiDrag) return;\n      for (let i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style[\"will-change\"] = \"\";\n\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl &&\n          toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n      cancel();\n    },\n\n    clone({ sortable, rootEl, dispatchSortableEvent, cancel }) {\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent(\"clone\");\n\n          cancel();\n        }\n      }\n    },\n\n    showClone({ cloneNowShown, rootEl, cancel }) {\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"\");\n      });\n\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n\n    hideClone({ sortable, cloneNowHidden, cancel }) {\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"none\");\n        if (this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n\n    dragStartGlobal({ sortable }) {\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach((multiDragElement) => {\n        //@ts-ignore\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n\n    dragStarted({ sortable }) {\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            css(multiDragElement, \"position\", \"absolute\");\n          });\n\n          //@ts-ignore\n          let dragRect = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRect);\n          });\n\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(() => {\n        folding = false;\n        initialFolding = false;\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (this.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n\n    dragOver({ target, completed, cancel }) {\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n\n    revert({ fromSortable, rootEl, sortable, dragRect }) {\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach((multiDragElement) => {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            //@ts-ignore\n            rect: folding ? getRect(multiDragElement) : dragRect,\n          });\n\n          unsetRect(multiDragElement);\n\n          multiDragElement.fromRect = dragRect;\n\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n\n    dragOverCompleted({\n      sortable,\n      isOwner,\n      insertion,\n      activeSortable,\n      parentEl,\n      putSortable,\n    }) {\n      let options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (\n          options.animation &&\n          multiDragElements.length > 1 &&\n          (folding ||\n            (!isOwner && !activeSortable.options.sort && !putSortable))\n        ) {\n          //@ts-ignore\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          let dragRectAbsolute = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            let clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (\n              activeSortable.options.animation &&\n              !clonesHidden &&\n              clonesHiddenBefore\n            ) {\n              multiDragClones.forEach((clone) => {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect,\n                });\n\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n\n    dragOverAnimationCapture({ dragRect, isOwner, activeSortable }) {\n      multiDragElements.forEach((multiDragElement) => {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (\n        activeSortable.options.animation &&\n        !isOwner &&\n        activeSortable.multiDrag.isMultiDrag\n      ) {\n        clonesFromRect = Object.assign({}, dragRect);\n        let dragMatrix = matrix(dragEl, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n\n    dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n\n    drop({\n      originalEvent: evt,\n      rootEl,\n      parentEl,\n      sortable,\n      dispatchSortableEvent,\n      oldIndex,\n      putSortable,\n    }) {\n      let toSortable = putSortable || this.sortable;\n\n      if (!evt) return;\n\n      let options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(\n          dragEl,\n          options.selectedClass,\n          !~multiDragElements.indexOf(dragEl)\n        );\n\n        if (!~multiDragElements.indexOf(dragEl)) {\n          multiDragElements.push(dragEl);\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"select\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (\n            evt.shiftKey &&\n            lastMultiDragSelect &&\n            sortable.el.contains(lastMultiDragSelect)\n          ) {\n            //@ts-ignore\n            let lastIndex = index(lastMultiDragSelect),\n              //@ts-ignore\n              currentIndex = index(dragEl);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              let n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n\n                dispatchEvent({\n                  sortable,\n                  rootEl,\n                  name: \"select\",\n                  targetEl: children[i],\n                  //@ts-ignore\n                  originalEvt: evt,\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"deselect\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if (\n          (parentEl[expando].options.sort || parentEl !== rootEl) &&\n          multiDragElements.length > 1\n        ) {\n          //@ts-ignore\n          let dragRect = getRect(dragEl),\n            multiDragIndex = index(\n              dragEl,\n              \":not(.\" + this.options.selectedClass + \")\"\n            );\n\n          if (!initialFolding && options.animation)\n            dragEl.thisAnimationDuration = null;\n\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl.fromRect = dragRect;\n              multiDragElements.forEach((multiDragElement) => {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl) {\n                  //@ts-ignore\n                  let rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect,\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n\n            multiDragElements.forEach((multiDragElement) => {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(\n                  multiDragElement,\n                  children[multiDragIndex]\n                );\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            //@ts-ignore\n            if (oldIndex === index(dragEl)) {\n              let update = false;\n              multiDragElements.forEach((multiDragElement) => {\n                //@ts-ignore\n                if (\n                  //@ts-ignore\n                  multiDragElement.sortableIndex !== index(multiDragElement)\n                ) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent(\"update\");\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        multiDragClones.forEach((clone) => {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n\n    nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n\n    destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, \"pointerup\", this._deselectMultiDrag);\n      off(document, \"mouseup\", this._deselectMultiDrag);\n      off(document, \"touchend\", this._deselectMultiDrag);\n\n      off(document, \"keydown\", this._checkKeyDown);\n      off(document, \"keyup\", this._checkKeyUp);\n    },\n\n    _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (\n        evt &&\n        closest(evt.target, this.options.draggable, this.sortable.el, false)\n      )\n        return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        let el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          //@ts-ignore\n          targetEl: el,\n          //@ts-ignore\n          originalEvt: evt,\n        });\n      }\n    },\n\n    _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n\n    _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    },\n  };\n\n  return Object.assign(MultiDrag, {\n    // Static methods & properties\n    pluginName: \"multiDrag\",\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select(el) {\n        let sortable = el.parentNode[expando];\n        if (\n          !sortable ||\n          !sortable.options.multiDrag ||\n          ~multiDragElements.indexOf(el)\n        )\n          return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect(el) {\n        let sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      },\n    },\n    eventProperties() {\n      const oldIndicies = [],\n        newIndicies = [];\n\n      multiDragElements.forEach((multiDragElement) => {\n        oldIndicies.push({\n          multiDragElement,\n          index: multiDragElement.sortableIndex,\n        });\n\n        // multiDragElements will already be sorted if folding\n        let newIndex;\n        if (folding && multiDragElement !== dragEl) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(\n            multiDragElement,\n            \":not(.\" + this.options.selectedClass + \")\"\n          );\n        } else {\n          //@ts-ignore\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement,\n          index: newIndex,\n        });\n      });\n      return {\n        items: [...multiDragElements],\n        clones: [...multiDragClones],\n        oldIndicies,\n        newIndicies,\n      };\n    },\n    optionListeners: {\n      multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === \"ctrl\") {\n          key = \"Control\";\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      },\n    },\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach((multiDragElement, i) => {\n    let target =\n      rootEl.children[\n        multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)\n      ];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach((clone, i) => {\n    let target =\n      rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach((multiDragElement) => {\n    if (multiDragElement === dragEl) return;\n    multiDragElement.parentNode &&\n      multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nexport default MultiDragPlugin;\n","import { getChild } from \"../../../utils/src\";\n\nconst drop = function ({\n  originalEvent,\n  putSortable,\n  dragEl,\n  activeSortable,\n  dispatchSortableEvent,\n  hideGhostForTarget,\n  unhideGhostForTarget,\n}) {\n  if (!originalEvent) return;\n  let toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  let touch =\n    originalEvent.changedTouches && originalEvent.changedTouches.length\n      ? originalEvent.changedTouches[0]\n      : originalEvent;\n  let target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent(\"spill\");\n    this.onSpill({ dragEl, putSortable });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart({ oldDraggableIndex }) {\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill({ dragEl, putSortable }) {\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    let nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop,\n};\n\nObject.assign(Revert, {\n  pluginName: \"revertOnSpill\",\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill({ dragEl, putSortable }) {\n    const parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop,\n};\n\nObject.assign(Remove, {\n  pluginName: \"removeOnSpill\",\n});\n\nexport default [Remove, Revert];\n\nexport { Remove as RemoveOnSpill, Revert as RevertOnSpill };\n","import {\n  on,\n  off,\n  css,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  getParentAutoScrollElement,\n  expando,\n  getRect,\n  getWindowScrollingElement,\n  Edge,\n  IE11OrLess,\n  Safari,\n} from \"../../../utils/src\";\n\nimport Sortable from \"../../../sortable/src/Sortable\";\n\nlet autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt,\n  pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true,\n    };\n\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted({ originalEvent }) {\n      if (this.sortable.nativeDraggable) {\n        on(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, \"pointermove\", this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, \"touchmove\", this._handleFallbackAutoScroll);\n        } else {\n          on(document, \"mousemove\", this._handleFallbackAutoScroll);\n        }\n      }\n    },\n\n    dragOverCompleted({ originalEvent }) {\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n\n    drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        off(document, \"pointermove\", this._handleFallbackAutoScroll);\n        off(document, \"touchmove\", this._handleFallbackAutoScroll);\n        off(document, \"mousemove\", this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n\n    nulling() {\n      touchEvt = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n\n      autoScrolls.length = 0;\n    },\n\n    _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n\n    _handleAutoScroll(evt, fallback) {\n      const x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n\n      touchEvt = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || Edge || IE11OrLess || Safari) {\n        //@ts-ignore\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        let ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (\n          scrolling &&\n          (!pointerElemChangedInterval ||\n            x !== lastAutoScrollX ||\n            y !== lastAutoScrollY)\n        ) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(() => {\n            let newElem = getParentAutoScrollElement(\n              document.elementFromPoint(x, y),\n              true\n            );\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            //@ts-ignore\n            autoScroll(evt, this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (\n          !this.options.bubbleScroll ||\n          getParentAutoScrollElement(elem, true) === getWindowScrollingElement()\n        ) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(\n          //@ts-ignore\n          evt,\n          this.options,\n          getParentAutoScrollElement(elem, false),\n          false\n        );\n      }\n    },\n  };\n\n  return Object.assign(AutoScroll, {\n    pluginName: \"scroll\",\n    initializeByDefault: true,\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nconst autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  const x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n\n  let scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n\n    clearAutoScrolls();\n\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  let layersOut = 0;\n  let currentParent = scrollEl;\n  do {\n    let el = currentParent,\n      //@ts-ignore\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX,\n      canScrollY,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      //@ts-ignore\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" ||\n          elCSS.overflowX === \"scroll\" ||\n          elCSS.overflowX === \"visible\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" ||\n          elCSS.overflowY === \"scroll\" ||\n          elCSS.overflowY === \"visible\");\n    } else {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" || elCSS.overflowX === \"scroll\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" || elCSS.overflowY === \"scroll\");\n    }\n\n    let vx =\n      canScrollX &&\n      //@ts-ignore\n      (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -\n        //@ts-ignore\n        (Math.abs(left - x) <= sens && !!scrollPosX);\n    let vy =\n      canScrollY &&\n      //@ts-ignore\n      (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -\n        //@ts-ignore\n        (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (let i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (\n      autoScrolls[layersOut].vx != vx ||\n      autoScrolls[layersOut].vy != vy ||\n      autoScrolls[layersOut].el !== el\n    ) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(\n          function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              //@ts-ignore\n              Sortable.active._onTouchMove(touchEvt); // To move ghost if it is positioned absolutely\n            }\n            let scrollOffsetY = autoScrolls[this.layer].vy\n              ? autoScrolls[this.layer].vy * speed\n              : 0;\n            let scrollOffsetX = autoScrolls[this.layer].vx\n              ? autoScrolls[this.layer].vx * speed\n              : 0;\n\n            if (typeof scrollCustomFn === \"function\") {\n              if (\n                scrollCustomFn.call(\n                  //@ts-ignore\n                  Sortable.dragged.parentNode[expando],\n                  scrollOffsetX,\n                  scrollOffsetY,\n                  evt,\n                  touchEvt,\n                  autoScrolls[this.layer].el\n                ) !== \"continue\"\n              ) {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({ layer: layersOut }),\n          24\n        );\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nexport default AutoScrollPlugin;\n","import Sortable from \"../../sortable/src/Sortable\";\nimport Swap from \"../../plugins/swap/src\";\nimport MultiDrag from \"../../plugins/multi-drag/src\";\nimport { RemoveOnSpill, RevertOnSpill } from \"../../plugins/on-spill/src\";\nimport AutoScroll from \"../../plugins/auto-scroll/src\";\n\n//@ts-ignore\nSortable.mount(new AutoScroll());\nSortable.mount(RemoveOnSpill, RevertOnSpill);\n//@ts-ignore\nSortable.mount(new Swap());\n//@ts-ignore\nSortable.mount(new MultiDrag());\n\nexport default Sortable;\nexport { Sortable };\n","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar propTypes = {\n  tag: tagPropType,\n  active: PropTypes.bool,\n  disabled: PropTypes.bool,\n  color: PropTypes.string,\n  action: PropTypes.bool,\n  className: PropTypes.any,\n  cssModule: PropTypes.object\n};\nvar defaultProps = {\n  tag: 'li'\n};\n\nvar handleDisabledOnClick = function handleDisabledOnClick(e) {\n  e.preventDefault();\n};\n\nvar ListGroupItem = function ListGroupItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      active = props.active,\n      disabled = props.disabled,\n      action = props.action,\n      color = props.color,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"tag\", \"active\", \"disabled\", \"action\", \"color\"]);\n\n  var classes = mapToCssModules(classNames(className, active ? 'active' : false, disabled ? 'disabled' : false, action ? 'list-group-item-action' : false, color ? \"list-group-item-\" + color : false, 'list-group-item'), cssModule); // Prevent click event when disabled.\n\n  if (disabled) {\n    attributes.onClick = handleDisabledOnClick;\n  }\n\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n};\n\nListGroupItem.propTypes = propTypes;\nListGroupItem.defaultProps = defaultProps;\nexport default ListGroupItem;"],"sourceRoot":""}